<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pharmacy Finder (類似検索・句読点全体除去・カタカナ変換版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 日本語フォント設定 (オプション) */
        body {
            font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif, "Hiragino Kaku Gothic ProN", "Meiryo", Meiryo, sans-serif;
        }
        /* ボタンのスタイル */
        .btn {
            @apply inline-block px-6 py-3 bg-blue-600 text-white font-medium text-sm leading-tight uppercase rounded-lg shadow-md hover:bg-blue-700 hover:shadow-lg focus:bg-blue-700 focus:shadow-lg focus:outline-none focus:ring-0 active:bg-blue-800 active:shadow-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed;
        }
        /* 出力エリアのスタイル */
        .output-box {
            @apply mt-4 p-4 border border-gray-300 rounded-lg bg-gray-50 min-h-[100px];
        }
        /* ステータス表示エリアのスタイル */
        .status-box {
             @apply mt-2 text-sm text-gray-600;
        }
    </style>
</head>
<body class="container mx-auto p-6 bg-gray-100 flex flex-col items-center justify-center min-h-screen">

    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg text-center">
        <h1 class="text-2xl font-bold mb-6">音声認識アプリ (類似検索・句読点除去・カタカナ変換版)</h1>

        <button id="startButton" class="btn">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 inline-block mr-2 align-middle">
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6 6 0 0 0 6-6v-1.5m-6 7.5a6 6 0 0 1-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 0 1-3-3V4.5a3 3 0 1 1 6 0v8.25a3 3 0 0 1-3 3Z" />
            </svg>
            音声入力開始
        </button>

        <div id="statusArea" class="status-box mt-4">準備完了</div>

        <div class="mt-6 text-left">
            <h2 class="text-lg font-semibold mb-2">認識結果：</h2>
            <div id="outputArea" class="output-box">ここに認識結果に対応するテキストが表示されます。</div>
        </div>
         <div class="mt-6 text-left">
            <h2 class="text-lg font-semibold mb-2">認識処理（認識語 → カタカナ化 → 最も近い登録語）：</h2>
            <div id="recognizedWordArea" class="output-box bg-gray-100">ここに認識された単語と処理プロセスが表示されます。</div>
        </div>
    </div>

    <script>
        // --- 設定箇所：ここから ---

        // 認識させたい単語と、それに対応する出力テキストのマッピング
        // ★注意：キーは基本的にカタカナで登録してください（比較のため）
        const wordMap = {
'トラゾドン': 'トラゾドン：棚A A-1',
'ジゴキシン': 'ジゴキシン：棚A A-2',
'メキシレチン': 'メキシレチン：棚A A-3',
'ボンビバ': 'ボンビバ：棚A A-4',
'アルファカルシドール': 'アルファカルシドール：棚A A-5',
'ゾルミトリブタン': 'ゾルミトリブタン：棚B B-1',
'イルアミクス': 'イルアミクス：棚B B-2',
'アムロビジン': 'アムロビジン：棚B B-3',
'グリメピソド': 'グリメピソド：棚B B-4',
'アレンドロン': 'アレンドロン：棚B B-5',
'マオウブシサイシントウ': '麻黄附子細辛湯：棚C C-1', // カタカナに変更
'まおうぶしさいしんとう': 'まおうぶしさいしんとう：棚C C-2', // ひらがなも残す場合（必要に応じて）
'アブリンジン': 'アブリンジン：棚C C-3',
'ニフェジピン': 'ニフェジピン：棚C C-4',
'オルケディア': 'オルケディア：棚C C-5',
'メトホルミン': 'メトホルミン：棚D D-1',
'コントミン': 'コントミン：棚D D-2',
'メプチン': 'メプチン：棚D D-3',
'ニコランジル': 'ニコランジル：棚D D-4',
'メトクロプラミド': 'メトクロプラミド：棚D D-5',
'ベオーバ': 'ベオーバ：棚E E-1',
'ジアゼバム': 'ジアゼバム：棚E E-2',
'デキストロメトルファン': 'デキストロメトルファン：棚E E-3',
'ショウサンイソソルビド': '硝酸イソソルビド：棚E E-4', // カタカナに変更
'モサブリドクエンサンエン': 'モサブリドクエン酸塩：棚E E-5', // カタカナに変更
'ノイロビタン': 'ノイロビタン：棚F F-1',
'ニトラゼパム': 'ニトラゼパム：棚F F-2',
'リンサンコデイン': 'リン酸コデイン：棚F F-3', // カタカナに変更
'プロセミド': 'プロセミド：棚F F-4',
'レバミピド': 'レバミピド：棚F F-5',
'メコバラミン': 'メコバラミン：棚G G-1',
'ゾルピデム': 'ゾルピデム：棚G G-2',
'トラネキサムサン': 'トラネキサム酸：棚G G-3', // カタカナに変更
'スピロノラクトン': 'スピロノラクトン：棚G G-4',
'エソメプラゾール': 'エソメプラゾール：棚G G-5',
'クエンサンダイイッテツナトリウム': 'クエン酸第一鉄ナトリウム：棚H H-1', // カタカナに変更
'デエビゴ': 'デエビゴ：棚H H-2',
'SPトローチ': 'SPトローチ：棚H H-3',
'トリクロルメチアシド': 'トリクロルメチアシド：棚H H-4',
'ランソプラゾール': 'ランソプラゾール：棚H H-5',
'ラロキシフェンエンサンエン': 'ラロキシフェン塩酸塩：棚I I-1', // カタカナに変更
'エチゾラム': 'エチゾラム：棚I I-2',
'ピーエイ': 'ピーエイ：棚I I-3',
'テノーミン': 'テノーミン：棚I I-4',
'オメプラゾーム': 'オメプラゾーム：棚I I-5',
'エゼチミブ': 'エゼチミブ：棚J J-1',
'カルコーパ': 'カルコーパ：棚J J-2',
'アンブロキソール': 'アンブロキソール：棚J J-3',
'ベラパミルエンサンエン': 'ベラパミル塩酸塩：棚J J-4', // カタカナに変更
'ラベプラゾールナトリウムエン': 'ラベプラゾールナトリウム塩：棚J J-5', // カタカナに変更
'ピタバスタチンカルシウム': 'ピタバスタチンカルシウム：棚K K-1',
'ドプス': 'ドプス：棚K K-2',
'フェキソフェナジンエンサンエン': 'フェキソフェナジン塩酸塩：棚K K-3', // カタカナに変更
'エンレスト': 'エンレスト：棚K K-4',
'ファモチジン': 'ファモチジン：棚K K-5',
'ファモチジンプラバスタチンナトリウム': 'ファモチジンプラバスタチンナトリウム：棚L L-1',
'ベタヒスチンメシルサンエン': 'ベタヒスチンメシル塩：棚L L-2', // カタカナに変更
'ロラタジン': 'ロラタジン：棚L L-3',
'テモカプリルエンサンエン': 'テモカプリル塩酸塩：棚L L-4', // カタカナに変更
'ウルソデオキシコールサン': 'ウルソデオキシコール酸：棚L L-5', // カタカナに変更 (酸塩 -> 酸)
'アロプリノール': 'アロプリノール：棚M M-1',
'バルプロサンナトリウム': 'バルプロ酸ナトリウム：棚M M-2', // カタカナに変更
'オロパタジンエンサンエン': 'オロパタジン塩酸塩：棚M M-3', // カタカナに変更
'イルベサルタン': 'イルベサルタン：棚M M-4',
'ニチファーゲン': 'ニチファーゲン：棚M M-5',
'フェブキソスタット': 'フェブキソスタット：棚N N-1',
'スルピリド': 'スルピリド：棚N N-2',
'ディレグラ': 'ディレグラ：棚N N-3',
'カルベジロール': 'カルベジロール：棚N N-4',
'マグミット': 'マグミット：棚N N-5',
'ジャヌビア': 'ジャヌビア：棚O O-1',
'カロナール': 'カロナール：棚O O-2',
'レボフロキサシン': 'レボフロキサシン：棚O O-3',
'リクシアナ': 'リクシアナ：棚O O-4',
'センノシド': 'センノシド：棚O O-5',
'ミグリトール': 'ミグリトール：棚P P-1',
'ロキソプロフェンナトリウム': 'ロキソプロフェンナトリウム：棚P P-2',
'セフカペンピボキシルエンサンエン': 'セフカペンピボキシル塩酸塩：棚P P-3', // カタカナに変更
'リマプロストアルファデクス': 'リマプロストアルファデクス：棚P P-4',
'ピコスルファートナトリウム': 'ピコスルファートナトリウム：棚P P-5',
'フォシーガ': 'フォシーガ：棚Q Q-1',
'プレガバリン': 'プレガバリン：棚Q Q-2',
'クラリスロマイシン': 'クラリスロマイシン：棚Q Q-3',
'ワルファリンカリウム': 'ワルファリンカリウム：棚Q Q-4',
'ブチルスコポラミンシュウカブツ': 'ブチルスコポラミン臭化物：棚Q Q-5', // カタカナに変更
'トラゼンタ': 'トラゼンタ：棚R R-1',
'ミオナール': 'ミオナール：棚R R-2',
'バラシクロビル': 'バラシクロビル：棚R R-3',
'シロスタゾール': 'シロスタゾール：棚R R-4',
'ビオスリー': 'ビオスリー：棚R R-5',
'ナフトピジル': 'ナフトピジル：棚S S-1',
'アスピリンチョウヨウ': 'アスピリン腸溶：棚S S-2', // カタカナに変更
'ゾフルーザ': 'ゾフルーザ：棚S S-3',
'クロピドグレル': 'クロピドグレル：棚S S-4',
'グーフィス': 'グーフィス：棚S S-5',
'プレドニゾロン': 'プレドニゾロン：棚T T-1',
'ロトロビン': 'ロトロビン：棚T T-2',
'ジスロマック': 'ジスロマック：棚T T-3',
'ボグリボース': 'ボグリボース：棚T T-4',
'ミヤBM': 'ミヤBM：棚T T-5',
        };

        // 類似検索のしきい値 (レーベンシュタイン距離)
        const SIMILARITY_THRESHOLD = 1; // しきい値は適宜調整してください

        // --- 設定箇所：ここまで ---

        const startButton = document.getElementById('startButton');
        const outputArea = document.getElementById('outputArea');
        const statusArea = document.getElementById('statusArea');
        const recognizedWordArea = document.getElementById('recognizedWordArea');

        // --- ひらがなをカタカナに変換する関数 ---
        function toKatakana(str) {
            if (typeof str !== 'string') {
                return str;
            }
            return str.replace(/[\u3041-\u3096]/g, function(match) {
                const charCode = match.charCodeAt(0) + 0x60;
                return String.fromCharCode(charCode);
            });
        }

        // --- レーベンシュタイン距離計算関数 ---
        function levenshteinDistance(s1, s2) {
            // ★比較前に両方をカタカナに変換（念のため）＆小文字化は不要
            // s1 = toKatakana(s1);
            // s2 = toKatakana(s2);

            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else {
                        if (j > 0) {
                            let newValue = costs[j - 1];
                            // ★文字コードレベルで比較
                            if (s1.charCodeAt(i - 1) !== s2.charCodeAt(j - 1)) {
                                newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                            }
                            costs[j - 1] = lastValue;
                            lastValue = newValue;
                        }
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

        // --- 最も近い単語と距離を見つける関数 ---
        function findBestMatch(transcript, map) {
            let minDistance = Infinity;
            let bestMatchKey = null;
            const keys = Object.keys(map);

            if (keys.length === 0) {
                return { bestMatchKey: null, minDistance: Infinity }; // マップが空の場合
            }

            // ★入力されたtranscriptは既にカタカナ化されている想定
            const katakanaTranscript = transcript; // toKatakana(transcript); // 事前変換済み

            for (const key of keys) {
                // ★wordMapのキーも念のためカタカナ変換して比較（ひらがなキーが混在する場合対策）
                const katakanaKey = toKatakana(key);
                const distance = levenshteinDistance(katakanaTranscript, katakanaKey);
                if (distance < minDistance) {
                    minDistance = distance;
                    bestMatchKey = key; // 元のキーを返す
                }
            }
            return { bestMatchKey, minDistance };
        }


        // Web Speech APIの互換性チェック
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP'; // 言語を日本語に設定
            recognition.interimResults = false; // 途中結果は取得しない
            recognition.maxAlternatives = 1; // 候補は1つだけ取得

            // --- イベントハンドラ ---

            recognition.onstart = () => {
                statusArea.textContent = '音声認識中... 話してください。';
                startButton.disabled = true;
                startButton.classList.add('animate-pulse');
            };

            recognition.onend = () => {
                statusArea.textContent = '準備完了';
                startButton.disabled = false;
                 startButton.classList.remove('animate-pulse');
            };

            // 結果取得 (修正箇所：カタカナ変換処理を追加)
            recognition.onresult = (event) => {
                const originalTranscript = event.results[0][0].transcript.trim(); // 認識された元の音声テキスト

                if (originalTranscript === "") {
                     statusArea.textContent = '音声が空でした。';
                     recognizedWordArea.textContent = '';
                     outputArea.textContent = '';
                     return;
                }

                // --- 文字列全体の句読点と空白を除去 ---
                const cleanedTranscript = originalTranscript.replace(/[。、！？\s]/g, '');

                // --- ★句読点除去後のテキストをカタカナに変換 ---
                const katakanaTranscript = toKatakana(cleanedTranscript);
                // -----------------------------------------

                // カタカナ変換後のテキストが空になった場合
                 if (katakanaTranscript === "") {
                     statusArea.textContent = '有効な単語が認識されませんでした（句読点/空白のみ）。';
                     // 元の認識結果と句読点除去後の結果を表示
                     recognizedWordArea.textContent = `認識：「${originalTranscript}」→ 処理後：「${cleanedTranscript}」（カタカナ変換不可）`;
                     outputArea.textContent = '';
                     return;
                 }

                // ★カタカナ変換後のテキストで最も近い単語とその距離を取得
                const { bestMatchKey, minDistance } = findBestMatch(katakanaTranscript, wordMap);

                // しきい値と比較
                if (bestMatchKey && minDistance <= SIMILARITY_THRESHOLD) {
                    // マッチした場合
                    outputArea.textContent = wordMap[bestMatchKey];
                    const matchedKeyKatakana = toKatakana(bestMatchKey); // 表示用にマッチしたキーもカタカナ化

                    if (minDistance === 0 && katakanaTranscript === matchedKeyKatakana) { // 完全一致の場合 (カタカナ同士で比較)
                        recognizedWordArea.textContent = `認識：「${originalTranscript}」 → カタカナ化：「${katakanaTranscript}」 → 完全一致：「${bestMatchKey}」`;
                        statusArea.textContent = `「${bestMatchKey}」を認識しました。`;
                    } else { // 近い単語の場合
                        recognizedWordArea.textContent = `認識：「${originalTranscript}」 → カタカナ化：「${katakanaTranscript}」 → 近い登録語：「${bestMatchKey}」(距離: ${minDistance})`;
                        statusArea.textContent = `「${katakanaTranscript}」に最も近い「${bestMatchKey}」として認識しました。`;
                    }
                } else {
                    // しきい値より大きい距離、またはマッチが見つからない場合
                    outputArea.textContent = '認識できませんでした。';
                    recognizedWordArea.textContent = `認識：「${originalTranscript}」 → カタカナ化：「${katakanaTranscript}」（登録語に一致せず）`;
                    if (bestMatchKey) {
                        statusArea.textContent = `「${katakanaTranscript}」を認識しましたが、登録語との距離が遠すぎます (最も近い語:「${bestMatchKey}」, 距離: ${minDistance})`;
                    } else {
                        // このケースは通常発生しないはず (findBestMatchは必ず何かキーを返すため)
                        statusArea.textContent = `「${katakanaTranscript}」を認識しましたが、登録語に一致しませんでした。`;
                    }
                }
            };

            // エラー処理
            recognition.onerror = (event) => {
                let errorMessage = '音声認識エラーが発生しました。';
                switch (event.error) {
                    case 'no-speech':
                        errorMessage = '音声が検出されませんでした。もう一度試してください。';
                        break;
                    case 'audio-capture':
                        errorMessage = 'マイクにアクセスできませんでした。設定を確認してください。';
                        break;
                    case 'not-allowed':
                        errorMessage = 'マイクの使用が許可されていません。';
                        break;
                    case 'network':
                         errorMessage = 'ネットワークエラーが発生しました。接続を確認してください。';
                         break;
                    default:
                        errorMessage = `エラー (${event.error}): ${event.message}`;
                }
                statusArea.textContent = errorMessage;
                outputArea.textContent = '';
                recognizedWordArea.textContent = '';
            };

            // --- ボタンのクリックイベント ---
            startButton.addEventListener('click', () => {
                try {
                    // 既に実行中の場合に停止しないようにする (必要であれば停止処理を追加)
                    // if (recognition && recognition.readyState === 'listening') {
                    //     recognition.stop();
                    // }
                    recognition.start();
                } catch (e) {
                    console.error("Recognition start error:", e);
                    // エラーメッセージは recognition.onerror で処理されることが多い
                    // statusArea.textContent = '認識を開始できませんでした。ブラウザの設定を確認するか、ページを再読み込みしてください。';
                    startButton.disabled = false; // エラー時もボタンを有効に戻す
                    startButton.classList.remove('animate-pulse');
                }
            });

        } else {
            // Web Speech APIがサポートされていない場合
            statusArea.textContent = 'お使いのブラウザは音声認識に対応していません。Google Chromeなどでお試しください。';
            startButton.disabled = true;
            outputArea.textContent = '音声認識機能を利用できません。';
        }

    </script>

</body>
</html>